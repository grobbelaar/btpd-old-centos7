
/*
 * Конфигурация с очередью и статистикой 
 * Основной поток сообщений: 
 *     main-server               - сервер 
 *     -> io-statistics1         - статистика входящего трафика
 *     -> jsonrpc-statistics    - статистика по API до очереди сообщений 
 *     -> jsonrpc-queue          - очередь сообщений (jsonrpc-workflow, jsonrpc-workflow-callback)
 *     -> prefixdb-statistics    - статистика по API (алгоритмы) 
 *     -> prefixdb-service       - десериализатор и вызов методов 
 *     -> prefixdb               - реализация API, прикладные алгаритмы (prefixdb-workflow)
 * 
 * Поток сообщений от порта cron-скриптов: 
 *     client-server
 *     -> io-statistics2
 *     -> client-statistics
 *     -> client-queue          (client-workflow)
 *     -> prefixdb-statistics
 *     -> prefixdb-service
 *     -> prefixdb
 * 
 * Поток сообщений от порта для слейва: 
 *     slave-server
 *     -> io-statistics3
 *     -> slave-statistics
 *     -> slave-queue          (slave-workflow)
 *     -> prefixdb-statistics
 *     -> prefixdb-service
 *     -> prefixdb              (prefixdb-workflow)
 *
 * 
 * system-statistics     |            main-ag
 * main-server           |
 * client-server         |
 * slave-server          |--> main-ag --------------|
 * io-statistics1        |                          |
 * io-statistics2        |                          |
 * io-statistics3        |                          |
 *                                                  |
 * prefixdb-workflow            |                   |
 * jsonrpc-workflow             |                   |
 * jsonrpc-workflow-callback    |--> workflow-ag ---|
 * client-workflow              |                   |
 * slave-workflow               |                   -> btp-gateway -> io-statistics-btp -> client-btp -> ... [ BTP- сервер ]
 *                                                  |
 * jsonrpc-statistics   |--> jsonrpc-ag ------------|
 *                                                  |
 * client-statistics    |--> client-ag -------------|
 *                                                  |
 * slave-statistics     |--> slave-ag --------------|
 *                                                  |
 * prefixdb-statistics  |--> prefixdb-ag -----------|
 *                                                  |
 * btp-gateway          |--> btp-ag ----------------|
 * io-statistics-btp    |
 * 
 */
{
  /* Разбирает параметры командной строки и запускает демон. Опций не имеет.*/
  "startup": {},

  /*****************************************************************/
  /* Читает и валидирует файл конфигурации.                        */
  /*****************************************************************/
  "config": {
    "enabled": true,
    /* Разрешить перечитывать конфигурацию по сигналу SIGHUP */
    "reload_sighup": false,
    /* Проверять на изменения конфигурацию и перечитывать ее. 0 - выкл.*/
    "reload_changed_ms": 0
    /* Примечание: Динамическое переконфигурирование работает крайне нестабильно, поэтому использовать в бою нельзя */
  },

  /*****************************************************************/
  /* Ядро WFC. Реализует алгоритмы инициализации и запуска системы */
  /*****************************************************************/
  "core": {
    /* Периодичность выполнения задач ядра (проверка на переинициализации при изменении конфигурации или флаг выхода)*/
    "core_timeout_ms": 1000,
    /* Запуск пользовательских задач в основном потоке демона */
    "idle_timeout_ms": 1000,
    /* Ограничение оперативной памяти */
    "rlimit_as_mb": 0,
    /* Зарезервировано (пока не работает)*/
    "enable_callback_check": true,

    /*Настройка workflow ядра */
    "core-workflow": {
      /* Число рабочих потоков. 0 - в основном потоке демона */
      "threads": 1,
      /* Использовать boost::io_service */
      "use_io_service": true

      /* Примечание: workflow - это очередь задач и пул потоков, который ее разгребает.
       *             Также поддерживает таймеры и реквестеры. Каждый прикладной объект 
       *             имеет доступ к workflow, если он не указан, то используется этот
       *             workflow ядра. См. также раздел "workflow"
       */
    },
    /* список ядер cpu для потоков WFC (потоки workflow, серверов и клиентов, а также пользовательских зарегистрированных потоков) */
    "cpu": [ ],
    /* список ядер cpu для всех остальных потоков */
    "unreg-cpu": []
  },

  /*****************************************************************/
  /* Система логирования                                           */
  /*****************************************************************/
  "logger": {
    /* При отключении модуля логирования сообщения выводятся в clog без форматирования */
    "enabled": true,
    /* Приоритет запуска. Должен быть минимальным в конфигурации, чтобы логирование запускалось раньше всех */
    "startup_priority": -1000,
    /* Аналогично, останов логирования должен происходить в последнюю очередь */
    "shutdown_priority": 1000,
    /* Отображать миллисекунды в логах */
    "milliseconds": true,
    /* Ограничение длинны лог-файла в байтах */
    "limit": 10000000,
    /* Стандартный вывод в режиме не-демона: cerr, cout или clog */
    "stdout": "clog",
    /* Путь для файла(ов) логов. В сингл режиме просто добавляется ".log" */
    "path": "/logs/prefixdb-master6",
    /* Разрешить писать в syslog (имя) */
    "syslog": "",
    /* Список запрещенных логов или типов логов в нижнем регистре */
    "deny": ["debug"],
    /* Если false то каждый лог пишется в отдельный файл, например /logs/dartc.domain.log */
    "single": true,
    "custom": {
      /* Карта кастомных настроек для каждого лога, например можно лог stat писать в отдельный файл */
      "stat":{
        "path": "/logs/prefixdb-master6-stat.log",
        "milliseconds": true
      }
    }
  },

  /*****************************************************************/
  /* Рабочие процессы                                              */
  /*****************************************************************/
  "workflow": [
    {
      /* workflow для собственно компонента prefixdb. Используется в основном для отложенной записи */
      "name": "prefixdb-workflow",
      "enabled": true,
      /* запускаем пораньше, чтобы очередь не разбухала */
      "startup_priority": -900,
      /* и раньше остальных завершаем, чтобы "сбросить" все задачи из очереди, выполнение которых будет тормозить процесс останова */
      "shutdown_priority": -900,
      
      /* Максимальный размер очереди (для jsonrpc в штатном режиме 1-2, разрастание очереди свидетельствует о том, что сервер не справляется) 
       * При запуске возможен кратковременное разрастание когда одновременно приходит множество запросов */
      "maxsize": 100000,
      /* Размер очереди при котором происходить предупреждение в лог */
      "wrnsize": 10,
      /* Периодичность записи предупреждения в лог (пока размер превосходит wrnsize) */
      "show_wrn_ms": 1000,
      /* Число рабочих потоков. 0 - в основном потоке демона */
      "threads": 1,
      "use_io_service": true,
      /* Обрабатывать задачи с задержкой. Например для 50 мс, означает что время ответа на запрос будет не менее 50мс. 
       * Можно открыть отдельный порт для кроновых скриптов и настроить очередь с задержкой, чтобы не сильно "валили" запросами */
      "post_delay_ms": 0,
      /* Ограничение по количеству обрабатываем задач ОДНИМ потоком. */
      "rate_limit": 0,
      /* Список выделенных ядер CPU для потоков этого workflow. Если пуст, то настройки ядра  WFC */
      "cpu": [],

      /* статистика по очередям и потокам */
      "statistics": {
        /* По умолчанию выключена, включаем */
        "disabled": false,
        /* Агрегатор статистики (см. statistics-aggregator)*/
        "target": "workflow-ag",
        /* Периодичность отправки метрик */
        "interval_ms": 100,
        
        /* Суфикс метрики для длины очереди (будет prefixdb-workflow.queue) */
        "queue": ".queue",
        /* Количество отброшеных задач с момента отправки пред. метрик из-за переполнения очереди */
        "dropped": ".dropped",
        /* Метрики по потокам (для каждого .thread0, .thread1 ... и общий .thread )
         * На графике count - количество выполненных задач, перцентили - время выполнения 
         * задач включая ожидание (если задачи поступают раз в сек, то и время выполнения ~сек)
         */
        "thread": ".thread"
      }
    },

    {
      /* workflow для основной jsonrpc очереди входящих запросов  */
      "name": "jsonrpc-workflow",
      "enabled": true,
      "startup_priority": -900,
      "shutdown_priority": -900,
      "maxsize": 100000,
      "wrnsize": 10,
      "show_wrn_ms": 1000,

      "threads": 6,
      "use_io_service": true,
      "post_delay_ms": 0,
      "rate_limit": 0,
      "cpu": [],

      "statistics": {
        "disabled": false,
        "target": "workflow-ag",
        "interval_ms": 500,
        "queue": ".queue",
        "dropped": ".dropped",
        "thread": ".thread"
      }
    },

    {
      /* workflow для основной jsonrpc очереди сериализации и отправки ответов на запросы  */
      "name": "jsonrpc-workflow-callback",
      "enabled": true,
      "startup_priority": -900,
      "shutdown_priority": -900,
      "statistics": {
        "disabled": false,
        "target": "workflow-ag",
        "interval_ms": 500,
        "queue": ".queue",
        "dropped": ".dropped",
        "thread": ".thread"
      },
      "maxsize": 100000,
      "wrnsize": 10,
      "show_wrn_ms": 1000,

      "threads": 2,
      "use_io_service": true,
      "post_delay_ms": 0,
      "rate_limit": 0,
      "cpu": []
    },

    {
      /* workflow для jsonrpc очереди входящих запросов от cron-скриптов и прочих клиентов которые могут давать 
         большую нагрузку, но не требовательны к времени ответа */
      "name": "client-workflow",
      "enabled": true,
      "startup_priority": -900,
      "shutdown_priority": -900,
      "statistics": {
        "disabled": false,
        "target": "workflow-ag",
        "interval_ms": 500,
        "queue": ".queue",
        "dropped": ".dropped",
        "thread": ".thread"
      },
      "maxsize": 100000,
      "wrnsize": 1000,
      "show_wrn_ms": 1000,

      "threads": 1,
      "use_io_service": true,
      "post_delay_ms": 0,
      "rate_limit": 0,
      "cpu": []
    },

    {
      /* workflow для jsonrpc очереди входящих запросов от слейвов */      
      "name": "slave-workflow",
      "enabled": true,
      "startup_priority": -900,
      "shutdown_priority": -900,
      "statistics": {
        "disabled": false,
        "target": "workflow-ag",
        "interval_ms": 500,
        "queue": ".queue",
        "dropped": ".dropped",
        "thread": ".thread"
      },
      "maxsize": 100000,
      "wrnsize": 1000,
      "show_wrn_ms": 1000,

      "threads": 1,
      "use_io_service": true,
      "post_delay_ms": 0,
      "rate_limit": 0,
      "cpu": []
    },
    
    {
      /* Для агрегатора статистики */
      "name": "ag-workflow",
      "enabled": true,
      "startup_priority": -900,
      "shutdown_priority": -900,
      "statistics": {
        "disabled": false,
        "target": "workflow-ag",
        "interval_ms": 100,
        "queue": ".queue",
        "dropped": ".dropped",
        "thread": ".thread"
      },
      "maxsize": 100000,
      "wrnsize": 1000,
      "show_wrn_ms": 1000,

      "threads": 1,
      "use_io_service": true,
      "post_delay_ms": 0,
      "rate_limit": 0,
      "cpu": []
    },
    
  ],

  /*****************************************************************/
  /* Агрегатор статистики демона                                   */
  /* Принимает и агрегирует статистику от других компонентов       */
  /*****************************************************************/
  "statistics-aggregator": [
    /* Несколько экземпляров чтобы не перегружать UI бтп большим количеством метрик на одном экране */
    {
      /* Базовые метрики демона (память, трафик) */
      "name": "main-ag",
      "enabled": true,
      /* В режиме suspend принимает данные, но ничего не делает */
      "suspend": false,
      /* workflow не указываем, т.к. отдельный workflow не нужен, достаточно workflow ядра*/
      "workflow": "ag-workflow",
      
      "statistics": {
        "disabled": false,
        /* Шаг агрегации. Лучше делать меньше 5 сек, чтобы графики не "скакали" в бтп */
        "step_ms": 1000,
        /* Ограничение массива значений для одного счетчика на шаг агрегации. Если за время 
           step_ms накопится больше, то начинается "прореживание" данных  */
        "limit": 4096,
        /* Уровни прореживания. limit*levels мак. кол-во собираемых значений до прореживания, остальные отбрасываются */
        "levels": 16,
        /* Размер прореженного массива сырых данных, который отправляем бтп. */
        "reduced_size": 4096,
        /* Размер пула буферов ( один буфер limit*8 байт ) */
        "pool": 0,
        /* Префиксы для счетчиков отправляемых в BTP. */
        "prefixes": [
          /* Общий счетчик для всех демонов PrefixDB */
          "service~~daemon:PrefixDB:main~~",
          /* Общий счетчик для всех демонов PrefixDB на запущенных на хосте cdaemon25 */
          "service~~daemon:PrefixDB:main~~cdaemon25~~",
          /* Счетчик для конкретного экземпляра демона PrefixDB */
          "script~~daemon:PrefixDB:main-master6~~daemon:PrefixDB:main~~"
        ]
      },
      /* Имя лога для дублирования статы ("" - чтобы не писать в лог) */
      "log":"",
      /* Периодичность отправки данных в БТП и записи в лог */
      "timeout_ms": 500,
      /* Игнорирование входящих значений при запуске заданное время, чтобы не "портить" графики большими всплесками */
      "btp_delay_ms": 30000,
      /* Шлюз БТП. Данные уже агрегированы, поэтому сразу отправляем на 5-сек демон*/
      "btp_target": "btp-gateway",
      /* Формат данных в логе: perseconds(в запр. сек), seconds, milliseconds, microseconds, nanoseconds, hide*/
      "log_metric": "microseconds"
    },

    /* Метрики от рабочих потоков и очередей */
    {
      "name": "workflow-ag",
      "enabled": true,
      "suspend": false,
      "workflow": "ag-workflow",
      "statistics": {
        "disabled": false,
        "reduced_size": 4096,
        "step_ms": 1000,
        "limit": 4096,
        "levels": 16,
        /* bytes = limit*pool  */
        "pool": 10,
        "prefixes": [
          "service~~daemon:PrefixDB:wrk~~",
          "service~~daemon:PrefixDB:wrk~~cdaemon25~~",
          "script~~daemon:PrefixDB:wrk-master6~~daemon:PrefixDB:wrk~~"
        ]
      },
      "timeout_ms": 500,
      "btp_delay_ms": 30000,
      "btp_target": "btp-gateway"
    },

    /* Метрики основного порта с учетом прохождения очереди */
    {
      "name": "jsonrpc-ag",
      "enabled": true,
      "suspend": false,
      "workflow": "ag-workflow",
      "statistics": {
        "disabled": false,
        "reduced_size": 4096,
        "step_ms": 1000,
        "limit": 4096,
        "levels": 16,
        /* bytes = limit*pool  */
        "pool": 10,
        "prefixes": [
          "service~~daemon:PrefixDB:srv~~",
          "service~~daemon:PrefixDB:srv~~cdaemon25~~",
          "script~~daemon:PrefixDB:srv-master6~~daemon:PrefixDB:srv~~",
          /* общие метрики для всех серверов */
          "service~~daemon:PrefixDB:jsonrpc~~",
          "service~~daemon:PrefixDB:jsonrpc~~cdaemon25~~",
          "script~~daemon:PrefixDB:jsonrpc-master6~~daemon:PrefixDB:jsonrpc~~"
        ]
      },
      "timeout_ms": 500,
      "btp_delay_ms": 30000,
      "btp_target": "btp-gateway"
    },

    /* Метрики вызовов методов непосредственно prefixdb */
    {
      "name": "prefixdb-ag",
      "enabled": true,
      "suspend": false,
      "workflow": "ag-workflow",
      "statistics": {
        "disabled": false,
        "reduced_size": 4096,
        "step_ms": 1000,
        "limit": 4096,
        "levels": 16,
        /* bytes = limit*pool  */
        "pool": 10,
        "prefixes": [
          "service~~daemon:PrefixDB:db~~",
          "service~~daemon:PrefixDB:db~~cdaemon25~~",
          "script~~daemon:PrefixDB:db-master6~~daemon:PrefixDB:db~~"
        ]
      },
      "timeout_ms": 500,
      "btp_delay_ms": 30000,
      "btp_target": "btp-gateway"
    },

    /* Метрики порта для крон скриптов */
    {
      "name": "client-ag",
      "enabled": true,
      "suspend": false,
      "workflow": "ag-workflow",
      "statistics": {
        "disabled": false,
        "reduced_size": 4096,
        "step_ms": 500,
        "limit": 4096,
        "levels": 16,
        /* bytes = limit*pool  */
        "pool": 10,
        "prefixes": [
          "service~~daemon:PrefixDB:cli~~",
          "service~~daemon:PrefixDB:cli~~cdaemon25~~",
          "script~~daemon:PrefixDB:cli-master6~~daemon:PrefixDB:cli~~",
          
          "service~~daemon:PrefixDB:jsonrpc~~",
          "service~~daemon:PrefixDB:jsonrpc~~cdaemon25~~",
          "script~~daemon:PrefixDB:jsonrpc-master6~~daemon:PrefixDB:jsonrpc~~"
        ]
      },
      "timeout_ms": 500,
      "btp_delay_ms": 30000,
      "btp_target": "btp-gateway"
    },

    /* Метрики порта для слейва */
    {
      "name": "slave-ag",
      "enabled": true,
      "suspend": false,
      "workflow": "ag-workflow",
      "statistics": {
        "disabled": false,
        "reduced_size": 4096,
        "step_ms": 100,
        "limit": 4096,
        "levels": 16,
        /* bytes = limit*pool  */
        "pool": 10,
        "prefixes": [
          "service~~daemon:PrefixDB:slave~~",
          "service~~daemon:PrefixDB:slave~~cdaemon25~~",
          "script~~daemon:PrefixDB:slave-master6~~daemon:PrefixDB:slave~~",
          
          "service~~daemon:PrefixDB:jsonrpc~~",
          "service~~daemon:PrefixDB:jsonrpc~~cdaemon25~~",
          "script~~daemon:PrefixDB:jsonrpc-master6~~daemon:PrefixDB:jsonrpc~~"
        ]
      },
      "timeout_ms": 500,
      "btp_delay_ms": 30000,
      "btp_target": "btp-gateway"
    },

    /* Отправка статистики тоже генерирует траффик, его тоже меряем чтобы следить что не перегружаем статой */
    {
      "name": "btp-ag",
      "enabled": true,
      "suspend": false,
      "workflow": "ag-workflow",
      "statistics": {
        "disabled": false,
        "reduced_size": 4096,
        "step_ms": 100,
        "limit": 4096,
        "levels": 16,
        /* bytes = limit*pool  */
        "pool": 10,
        "prefixes": [
          "service~~daemon:PrefixDB:btp~~",
          "service~~daemon:PrefixDB:btp~~cdaemon25~~",
          "script~~daemon:PrefixDB:btp-master6~~daemon:PrefixDB:btp~~"
        ]
      },
      "timeout_ms": 500,
      "btp_delay_ms": 30000,
      "btp_target": "btp-gateway"
    }

  ],
  
  /*****************************************************************/
  /* Системная статистика демона                                   */
  /*****************************************************************/
  "system-statistics": [
    {
      "name": "system-statistics",
      "enabled": true,
      "suspend": false,
      "startup_priority": 0,
      "shutdown_priority": 0,
      "workflow": "",
      "statistics": {
        "disabled": false,
        "target": "main-ag",
        /* Пока вшиты метрики rss (resident set size), utime, stime, можно задать для них префикс. */
        "prefix": "",
        "interval_ms": 500
      }
    }
  ],
  
  /*****************************************************************/
  /* Шлюз BTP                                                      */
  /*****************************************************************/
  "btp-gateway": [
    /* Реализует API btp и преобразует вызовы в jsonrpc запросы которые отправляет на сервер через client-tcp
     * Основные настройки такие же как и для сервисов
     */
    {
      "name": "btp-gateway",
      "enabled": true,
      "suspend": false,
      "startup_priority": 0,
      "shutdown_priority": 0,
      "workflow": "",
      "statistics": {
        /* Статистику включаем, т.к. используем очередь ожидания результатов на запрос. По ней можем отследить, что бтп втупил */
        "disabled": true,
        "target": "btp-ag",
        "interval_ms": 200,
        "handler_map": ".handler_map",
        "result_queue": ".result_queue "
      },

      
      /* Куда отправлять исходящие запросы (сначала змеряем трафик ) */
      "outgoing_target": "io-statistics-btp",
      /* Инициирует подключение клиента client-tcp к серверу при старте*/
      "outgoing_reg": true,
      
      /* Цель для встречных входящих запросов (БТП таких не делает ) */
      "incoming_target": "",
      "incoming_reg": false,
      /* Для шлюза в данном случае отключать нельзя */
      "disable_handler_map": false,

      /* Следующие опции работают только при "disable_handler_map": false */
      /* Максимальное время ожидания ответа на встречный запрос */
      "call_lifetime_ms": 60000,
      /* Осуществлять проверку очереди при каждом запросе */
      "remove_everytime": true,
      /* Периодичность удаления устаревших запросов из очереди ожидания */
      "remove_outdated_ms": 1000
    }
  ],

  /*****************************************************************/
  /* TCP сервер                                                    */
  /*****************************************************************/

  "server-tcp": [

    /* Основной порт*/
    {
      "name": "main-server",
      "enabled": true,
      /* В режиме suspend работает как эхо-сервер */
      "suspend": false,
      /* Порты открываем в последнюю очередь */
      "startup_priority": 1000,
      /* А закрываем в первую, чтобы входящий поток запросов не мешал корректно завершить работу */
      "shutdown_priority": -1000,
      /* Здесь используется свой пул запросов, workflow только для таймеров, можно использовать workflow ядра */
      "workflow": "",
      /* Статистика по потокам аналогично workflow ("thread": ".thread") имена пока вшиты */
      "statistics": {
        "disabled": false,
        /* Имя агрегатора статистики */
        "target": "main-ag"
      },
      /* Следующий по цепочке компонент сбора io-статистики, для мониторинга входящего трафика */
      "target": "io-statistics1",
      /* Включает поддержку keep-alive */
      "keep-alive": true,
      /* Список выделенных ядер CPU для потоков этого сервера. Если пуст, то настройки ядра WFC */
      "cpu": [],

      /* Количество потоков.
       * В каждом потоке "висит" акцептор и в нем же обрабатываются сокеты, которые принял акцептор.
       * Если используется входящая очередь ( io-queue из пакета wfc_io или jsonrpc-queue из пакета wfc_jsonrpc)
       * то нет смысла запускать большое количество потоков, с парсингом и сборкой по простому разделителю сервер 
       * справляется достаточно эффективно.
       * Если время ответа от прикладной логики стабильно мало (более 100000 запросов в сек. ( или менее 10 мкс) ) 
       * то имеет смысл отключить очереди и увеличить количество потоков сервера. На общее время ответа это не сильно 
       * повлияет, но заметно снизит нагрузку на CPU.
       * Архитектура "один слушатель" + "пул воркеров" не поддерживается, т.к. по производительности и ресурсам 
       * она не превосходит схему сервер+очередь, но имеет те же недостатки варианта сервер без очереди (при тяжелом 
       * запросе остальные сокеты потока вынуждены ждать 
       */
      "threads": 1,
      /*ip адрес или имя хоста*/
      "addr": "0.0.0.0",
      "port": "23560",
      /* Очередь входящих запросов на соединение (linux) */
      "backlog": 1024,
      /* Ограничение на количество одновременных подключений (сервер)*/
      "max_connections": 0,

      /* настройки для коннектов */
      "connection": {
        /* 'Читатель' из сокета */
        "reader": {
          /* разделитель входного потока*/
          "sep": "\r\n",
          /* Буфер для операции чтения. Можно уменьшить, если все запросы короткие, 
           * но нет смысла увеличивать больше 8-32Кб даже для больших запросов или 
           * потока сообщений по одному подключению */
          "bufsize": 4096,
          /* Максимальный размер чанка входящего буфера, после которого происходит разделение на массивы размером не более bufsize */
          "maxbuf": 8192,
          /* Если при разделении, последний буфер меньше minbuf то он сливается с предпоследним, при условии, что не будет превышен maxbuf*/ 
          "minbuf": 0,
          /* Удалять разделитель из сообщения*/
          "trimsep": true
        },
        /* 'Писатель' в сокет */
        "writer": {
          /* Добавляет разделитель в конец сообщения */
          "sep": "\r\n",
          /* Буфер для операции записи. */
          "bufsize": 8192,
          /* Максимальный размер чанка исходящего буфера, после которого происходит разделение на массивы размером не более bufsize */
          "maxbuf": 8192,
          /* Если при разделении, последний буфер меньше minbuf то он сливается с предпоследним, при условии, что не будет превышен maxbuf*/ 
          "minbuf": 0,
          /* Если исходящий буфер пуст, а размер сообщения превышает maxbuf, то делается попытка записать сообщение целиком 
             и только потом остаток сообщения разбивается на чанки размером bufsize. Эффективно работает на сообщениях до 1Мб, если больше
             то эффективнее предварительно разбить на массивы 16-32Кб   */
          "first_as_is": true
        }
      }
    },

    /* Порт для крон-скриптов */
    {
      "name": "client-server",
      "enabled": true,
      "suspend": false,
      "startup_priority": 1000,
      "shutdown_priority": -1000,
      "workflow": "",
      "statistics": {
        "disabled": false,
        "target": "main-ag"
      },

      "target": "io-statistics2",
      "keep-alive": true,
      "cpu": [],
      "threads": 1,
      "addr": "0.0.0.0",
      "port": "23561",
      "backlog": 1024,
      "max_connections": 0,

      "connection": {
        "reader": {
          "sep": "\r\n",
          "bufsize": 4096,
          "maxbuf": 8192,
          "minbuf": 0,
          "trimsep": true
        },
        "writer": {
          "sep": "\r\n",
          "bufsize": 512,
          "maxbuf": 8192,
          "minbuf": 0,
          "first_as_is": true
        }
      }
    },

    /* Порт для слейва */
    {
      "name": "slave-server",
      "enabled": true,
      "suspend": false,
      "startup_priority": 1000,
      "shutdown_priority": -1000,
      "workflow": "",
      "statistics": {
        "disabled": false,
        "target": "main-ag"
      },

      "target": "io-statistics3",
      "keep-alive": true,
      "cpu": [],
      "threads": 1,
      "addr": "0.0.0.0",
      "port": "23562",
      "backlog": 1024,
      "max_connections": 0,

      "connection": {
        "reader": {
          "sep": "\r\n",
          "bufsize": 4096,
          "maxbuf": 8192,
          "minbuf": 0,
          "trimsep": true
        },
        "writer": {
          "sep": "\r\n",
          "bufsize": 8192,
          "maxbuf": 8192,
          "minbuf": 0,
          "first_as_is": true
        }
      }
    },

    /* raw-порт */
    {
      "name": "raw-server",
      "enabled": true,
      "target": "prefixdb",
      "threads": 0,
      "addr": "0.0.0.0",
      "port": "23563"
    }
  ],

  /*****************************************************************/
  /* Статистика входящего/исходящего трафика                       */
  /*****************************************************************/
  "io-statistics": [
    /* трафик основного сервера*/
    {
      "name": "io-statistics1",
      "enabled": true,
      "suspend": false,
      "statistics": {
        "disabled": false,
        "target": "main-ag"
      },
      /* Далее собираем jsonrpc-статистику */
      "target": "jsonrpc-statistics",
      /* Интервал отправки в агрегатор статистики */
      "interval_ms": 100,
      /* Имя для количества одновременных коннектов  */
      "io_name": "connections",
      /* Имя метрики обработки одного сообщения (включая прохождение по очередям) */
      "time_name":  "srv-time",
      /* Имя метрики для входящего трафика (в count- общий трафик, в перцентилях размеры пакетов */
      "read_name":  "srv-read_size",
      /* Имя метрики для исходящего трафика (в count- общий трафик, в перцентилях размеры пакетов */
      "write_name": "srv-write_size"
    },

    /* трафик сервера для скриптов */
    {
      "name": "io-statistics2",
      "enabled": true,
      "suspend": false,
      "statistics": {
        "disabled": false,
        "target": "main-ag"
      },
      "target": "client-statistics",
      "interval_ms": 100,
      "io_name": "connections",
      "time_name": "cli-time",
      "read_name": "cli-read_size",
      "write_name": "cli-write_size"
    },
    
    /* трафик сервера для слейва */
    {
      "name": "io-statistics3",
      "enabled": true,
      "suspend": false,
      "statistics": {
        "disabled": false,
        "target": "main-ag"
      },
      "target": "slave-statistics",
      "interval_ms": 100,
      "io_name": "connections",
      "time_name": "slave-time",
      "read_name": "slave-read_size",
      "write_name": "slave-write_size"
    },
    /* исходящий трафик для btp*/
    {
      "name": "io-statistics-btp",
      "enabled": true,
      "suspend": false,
      "statistics": {
        "disabled": false,
        "target": "btp-ag"
      },
      "target": "client-btp",
      "interval_ms": 100,
      "io_name": "connections",
      "time_name"  :  "btp-time",
      /* Меняем название, т.к. входящий для io-statistics-btp это исходящий на бтп */
      "read_name"  :  "btp-write_size",
      "write_name" : "btp-read_size"
    }
  ],

  /*****************************************************************/
  /* Очередь jsonrpc-запросов                                      */
  /*****************************************************************/

  "jsonrpc-queue": [
    /* Основная очередь  */
    {
      "name": "jsonrpc-queue",
      "enabled": true,
      "suspend": false,
      "startup_priority":0,
      "shutdown_priority": 0,
      /* Это workflow для входящей очереди */
      "workflow": "jsonrpc-workflow",
      /* И еще раз отправляем на сбор статистики  */
      "target": "prefixdb-statistics",
      
      /* Можно задать workflow для исходящей очереди. Имеет смысл только при тяжелых ответах на запрос 
         и/или ответ в прикладной области отправляется под мьютексом. В данном случае на время ответа не 
         повлияет но увеличит нагрузку на CPU  */
      "callback_queue": true,
      "callback_workflow": "jsonrpc-workflow-callback"
    },
    /* Очередь для cron скриптов  */
    {
      "name": "client-queue",
      "enabled": true,
      "suspend": false,
      "startup_priority": 0,
      "shutdown_priority": 0,
      "workflow": "client-workflow",
      "target": "prefixdb-statistics",
      "callback_queue": false,
      "callback_workflow": ""
    },
    /* Очередь для слейва */
    {
      "name": "slave-queue",
      "enabled": true,
      "suspend": false,
      "startup_priority": 0,
      "shutdown_priority": 0,
      "workflow": "slave-workflow",
      "target": "prefixdb-statistics"
    }
  ],

  /*****************************************************************/
  /* Статистика jsonrpc-запросов                                   */
  /*****************************************************************/
  "jsonrpc-statistics": [
    {
      /* Сбора статистики с учетом прохождения очередей с основного порта */
      "name": "jsonrpc-statistics",
      "enabled": true,
      "suspend": false,
      "statistics": {
        "disabled": false,
        "target": "jsonrpc-ag"
      },
      /* Далее отправляем запрос в очередь. Таким образом время выполнения метода с учетом прохождения очереди*/
      "target": "jsonrpc-queue",
      /* Включить статистику размеров результатов вызова*/
      "enable_write_size": true,
      /* Включить стату по ошибкам */
      "enable_error_stat": true,
      /* суффикс для времен (пример: req:get.time) */
      "time_suffix": ".time",
      /* суффикс для размера входящих запросов  */
      "read_size_suffix": ".rsize",
      /* суффикс для размера исходящих запросов  */
      "write_size_suffix": ".wsize",
      /* Префикс для запросов (пример: req:get.time)*/
      "request_prefix": "req:",
      /* Префикс для уведомлений */
      "notify_prefix": "ntf:",
      
      /* Для прочего валидного jsonrpc, но мусора */
      "other_time": "other.time",
      "other_read_size": "other.rsize",
      "other_write_size": "other.wsize"
    },
    
    /* Общая статистика запросов prefixdb ( метрики непосредственно синхроного вызова )*/
    {
      "name": "prefixdb-statistics",
      "enabled": true,
      "suspend": false,
      "statistics": {
        "disabled": false,
        "target": "prefixdb-ag"
      },
      /* Отправляеи на service который синхронно десериализует и сделает вызов */
      "target": "prefixdb-service",
      "enable_write_size": true,
      "enable_error_stat": true,
      "time_suffix": ".time",
      "read_size_suffix": ".rsize",
      "write_size_suffix": ".wsize",
      "request_prefix": "req:",
      "notify_prefix": "ntf:",
      "other_time": "other.time",
      "other_read_size": "other.rsize",
      "other_write_size": "other.wsize"
    },

    /* Сбора статистики с учетом прохождения очередей с порта для cron-скриптов */
    {
      "name": "client-statistics",
      "enabled": true,
      "suspend": false,
      "statistics": {
        "disabled": false,
        "target": "client-ag"
      },
      "target": "client-queue",
      "enable_write_size": true,
      "enable_error_stat": true,
      "time_suffix": ".time",
      "read_size_suffix": ".rsize",
      "write_size_suffix": ".wsize",
      "request_prefix": "req:",
      "notify_prefix": "ntf:",
      "other_time": "other.time",
      "other_read_size": "other.rsize",
      "other_write_size": "other.wsize"
    },
    
    /* Сбора статистики с учетом прохождения очередей с порта для слейва */
    {
      "name": "slave-statistics",
      "enabled": true,
      "suspend": false,
      "statistics": {
        "disabled": false,
        "target": "slave-ag"
      },
      "target": "slave-queue",
      "enable_write_size": true,
      "enable_error_stat": true,
      "time_suffix": ".time",
      "read_size_suffix": ".rsize",
      "write_size_suffix": ".wsize",
      "request_prefix": "req:",
      "notify_prefix": "ntf:",
      "other_time": "other.time",
      "other_read_size": "other.rsize",
      "other_write_size": "other.wsize"
    }
  ],

  /*****************************************************************/
  /* Сервис PrefixDB                                               */
  /*****************************************************************/

  "prefixdb-service": [
    /* Десериализует параметры запроса и осуществляет вызов метода прикладного объекта*/
    {
      "name": "prefixdb-service",
      "enabled": true,
      "suspend": false,
      "startup_priority": 0,
      "shutdown_priority": 0,
      /* Только для сбора статы. Достаточно общего workflow ядра WFC*/
      "workflow": "", 

      "statistics": {
        /* Статистику выключаем т.к. disable_handler_map реестр не запросов ведется */
        "disabled": true
      },

      /* Прикладной объект*/
      "target": "prefixdb",

      /*  Пропускать не JSON-RPC запросы. Может использоваться если в прикладном объекте реализован 
       *  метод iinterface::perfom_io для произвольных сообщений. Обычно для этого открывают другой 
       *  порт, но если сервер соединен непосредственно с сервисом, то можно по одному порту  */
      "allow_non_jsonrpc": true,

      /* В большинстве случаев не нужно отслеживать подключение/отключение клиентов, а также делать 
       * встречные вызовы (с сервера к клиенту), поэтому отключаем реестр вызовов (автоматически отключается 
       * очередь ожидания ответов на запросы)*/
      "disable_handler_map": false,

      /* Следующие опции работают только при "disable_handler_map": false */
      "call_lifetime_ms": 3000,
      "remove_everytime": true,
      "remove_outdated_ms": 1000
    }
  ],

  /*****************************************************************/
  /* prefixdb                                                      */
  /*****************************************************************/
  "prefixdb": [
    {
      "name": "prefixdb",
      "enabled": true,
      /* В suspend режиме отправляет пустой ответ. Может быть использован для отладки производительности.
       * (Если есть существенная разница в suspend и не-suspend то основные ресурсы уходят на прикладную логику) */
      "suspend": false,
      /* Должен запускаться после клиента мастера, иначе может не подцепиться репликация */
      "startup_priority": 0,
      "shutdown_priority": 0,
      /* Для таймеров слева и очереди отложенной записи */
      "workflow": "prefixdb-workflow",
      /* Сканирует папку о открывает БД префиксов иначе только при первом запросе */
      "preopen": true,
      /* Ограничение на количество ключей в одном запросе */
      "keys_per_req": 100,
      /* Максимальная длина ключа в запросе */
      "key_size_limit": 256,
      /* Максимальный размер значения в запросе */
      "value_size_limit": 10240,
      /*Ограничение на длину имени префикса */
      "prefix_size_limit": 256,
      /* Максимальная длина префикса в запросе */
      "max_prefixes": 128,
      /* Путь к БД префиксов */
      "path": "/monamour/prefixdb/master6",
      /* WAL можно хранить в другом месте ( например SSD ) */
      "wal_path": "",
      /* Путь куда будут перемещаться БД префиксов при вызове detach_prefix */
      "detach_path": "/monamour/prefixdb/master6_detach",
      /* максимальный размер хранимых json-объектов (не реализовано) */
      "packed_limit": 1000,
      /* максимальный размер хранимых json-массивов (не реализовано) */
      "array_limit": 1000,
      /* ограничение на количество возвращаемых ключей для range за один запрос  */
      "range_limit": 10000,
      /* Отложенная запись через очередь. Уменьшается время ответа на модифицирующие запросы 
       * если не нужен результат и не задан параметр sync в запросе. Внимание! Если не задан 
       * sync в запросе, то фактическая запись в базу может быть произведена позже, чем клиент 
       * получит ответ об успешной операции. Если в этот момент демон останавливается, то 
       * все запросы в очереди теряются 
       */
      "enable_delayed_write": true,
      /* Автоматическое восстановление при старте на поврежденной базе */
      "auto_repair": false,
      /* Завершить работу при ошибке открытия БД*/
      "abort_if_open_error": true,
      /* Проверять json в операциях типа package */
      "check_merge_operations": true,
      /* ini-конфиг для RocksDB */
      "ini": "./rocksdb.ini",
      /*"ini": "/usr/monamour/prefixdb/rocksdb.ini",*/

      /* Периодическое переуплотнение БД префиксов (может ускорить работу после удаления массива данных )*/
      "compact": {
        /* Запускать сразу после открытия(работает только с preopen=true и независимо от "enabled")*/
        "startup_compact": false,
        /* Вкл/выкл периодическое переуплотнение (не влияет на startup_compact) 
           Если не заданы start_time и period_s то раз в сутки с момента запуска
          */
        "enabled": false,
        /* Запускать в заданное время, например 03:00:00 */
        "start_time": "",
        /* Если не задано, то раз в сутки. Если не ноль и start_time="" то с заданой периодичностью с 
           момента запуска или начиная со времени start_time */
        "period_s": 0
      },

      /* Опции восстановления по умолчанию. Для запуска восстановления:
         # восстановление с текущего бэкапа в соответствии с настройками 
         ./prefixdb -C conf --instance-options="prefixdb:restore"
         # восстановление с указанного бэкапа 
         ./prefixdb -C conf --instance-options="prefixdb:restore=/monamour2/prefixdb/slave6_backup"
         # восстановление с указанной точки 
         ./prefixdb -C conf --instance-options="prefixdb:pid=3:restore=/monamour2/prefixdb/slave6_backup"
        */
      "restore": {
        /* Запретить восстановление для данной конфигурации */
        "forbid": true,
        /* Точка восстановления по умолчанию */
        "backup_id": 0,
        /* Путь к бэкапу по умолчанию */
        "path": "/monamour/prefixdb/slave6_backup"
      },
      /* Устарело */
      "stop_list": []
    }
  ],

  /*****************************************************************/
  /* TCP клиент                                                    */
  /*****************************************************************/
  "client-tcp": [
    /* Подключение к BTP */
    {
      "name": "client-btp",
      "enabled": true,
      "suspend": false,
      "startup_priority": -500,
      "shutdown_priority": 500,
      
      "addr": "cdaemon22",
      "port": "37100",
      "threads": 1,
      "async_connect": false,
      "reconnect_timeout_ms": 1000
    }
  ]
}
